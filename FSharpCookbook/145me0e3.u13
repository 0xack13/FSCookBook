//F# cookbook

// Using List properties
//'%A' formats any value white '%d' formats any integer value
let names = [ 1; 2; 3; 4; 5; 6; ]
printfn "names.IsEmpty is %b" (names.IsEmpty)
printfn "names.Length is %d" (names.Length)
printfn "names.Head is %d" (names.Head)
printfn "names.Tail is %A" (names.Tail)
printfn "names.Tail.Head is %A" (names.Tail.Head)
printfn "names.Tail.Tail.Head is %d" (names.Tail.Tail.Head)
printfn "names.Item(1) is %d" (names.Item(1))


let genericA<'a> = 2 //"Hello World!" will work as well
printfn "%A" genericA

// Generic List: a & b are inferred to be the same type
let makeList a b =
    [a; b]
makeList "Hello " "There!"

// Define Generic Type using '
let genericAType : 'a // In C#: string genericAType<a>();   
let genericAType t = "test"

// Define Generic Function
let function3 (x : 'a) (y : 'a) =
    printf "%A %A" x y
function3("Hello ")("There!") // Result: "Hello " "There!"

// Type extension for Generic Array
type 'a ``[]`` with
  member x.GetOrDefault(n) = 
    if x.Length > n then x.[n]
    else Unchecked.defaultof<'a>
 
let arr = [|1; 2; 3|]
arr.GetOrDefault(1) //2
arr.GetOrDefault(4) //0

//Using Sequence Expression
let values = seq { 1 .. 10 }
let doubled = Seq.map (fun v -> v * 2) values // [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]

// 3 ways to print Seq variable (mainly in the interactive shell)
printfn "%A" doubled
printfn "%A" (Seq.toList doubled);;
doubled;;

// Using Some and None keywords
let keepIfPositive (a : int) = if a > 0 then Some(a) else None
keepIfPositive(-2)
keepIfPositive(2)

// Common Usage of "Option" in F#
let rec tryFindMatch pred list =
    match list with
    | head :: tail -> if pred(head)
                        then Some(head)
                        else tryFindMatch pred tail
    | [] -> None

// result1 is Some 100 and its type is int option.
let result1 = tryFindMatch (fun elem -> elem = 100) [ 200; 100; 50; 25 ] 

// result2 is None and its type is int option.
let result2 = tryFindMatch (fun elem -> elem = 26) [ 200; 100; 50; 25 ]

//Using recursive function
let add a b = a + b
add 1 2 
let rec add_all l = 
  match l with
    | [] -> 0
    | head :: tail -> head + add_all tail
add_all [1; 2; 3; 4] // returns 10
